/* SwiftTunnel SDK - Auto-generated C header. Do not edit. */

#ifndef SWIFTTUNNEL_H
#define SWIFTTUNNEL_H

/* Warning: this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Default port for OAuth callback server
 */
#define DEFAULT_OAUTH_PORT 17435

#define SUCCESS 0

#define ERROR_INVALID_PARAM -1

#define ERROR_NOT_INITIALIZED -2

#define ERROR_ALREADY_CONNECTED -3

#define ERROR_NOT_CONNECTED -4

#define ERROR_INTERNAL -5

#define ERROR_AUTH -6

#define ERROR_NETWORK -7

#define ERROR_CONFIG -8

#define ERROR_SPLIT_TUNNEL -9

#define ERROR_VPN -10

/**
 * Initialise the SDK: create runtime, logger, and global state.
 * Returns 0 on success, negative on error.
 */
int32_t swifttunnel_init(void);

/**
 * Tear down the SDK: disconnect if connected, drop all state.
 */
void swifttunnel_cleanup(void);

/**
 * Return the SDK version string.  Caller must free with `swifttunnel_free_string`.
 */
char *swifttunnel_version(void);

/**
 * Free a string previously returned by the SDK.
 */
void swifttunnel_free_string(char *ptr);

/**
 * Sign in with email and password.  Returns 0 on success.
 */
int32_t swifttunnel_auth_sign_in(const char *email, const char *password);

/**
 * Start Google OAuth flow.  Returns the URL to open in a browser.
 * Caller must free the returned string.  Returns null on error.
 */
char *swifttunnel_auth_start_oauth(void);

/**
 * Poll for OAuth callback.
 * Returns 1 if complete (logged in), 0 if still waiting, -1 on error.
 */
int32_t swifttunnel_auth_poll_oauth(void);

/**
 * Cancel an in-progress OAuth flow.
 */
void swifttunnel_auth_cancel_oauth(void);

/**
 * Refresh the access token.  Returns 0 on success.
 */
int32_t swifttunnel_auth_refresh(void);

/**
 * Sign out and clear stored credentials.
 */
void swifttunnel_auth_sign_out(void);

/**
 * Check if a user is currently logged in.  Returns 1 or 0.
 */
int32_t swifttunnel_auth_is_logged_in(void);

/**
 * Get user info as JSON.  Returns null if not logged in.
 * Caller must free the returned string.
 *
 * JSON shape: `{"id":"...","email":"...","is_tester":false}`
 */
char *swifttunnel_auth_get_user_json(void);

/**
 * Fetch the server list from the API (or cache).  Returns 0 on success.
 */
int32_t swifttunnel_servers_fetch(void);

/**
 * Get the cached server list as JSON.  Returns null if not fetched yet.
 * Caller must free the returned string.
 *
 * JSON shape: `{"servers":[...],"regions":[...]}`
 */
char *swifttunnel_servers_get_json(void);

/**
 * Ping a server region and return latency in ms.  Returns -1 on error.
 */
int32_t swifttunnel_servers_ping(const char *region);

/**
 * Connect to a VPN server (legacy API, auto-routing disabled).
 */
int32_t swifttunnel_connect(const char *region, const char *apps_json);

/**
 * Connect using JSON options.
 *
 * JSON contract:
 * `{ \"region\": \"singapore\", \"apps\": [\"RobloxPlayerBeta.exe\"], \"custom_relay_server\": \"relay.example.com:51821\", \"auto_routing\": { \"enabled\": true, \"whitelisted_regions\": [\"US East\"] }, \"forced_servers\": {\"us-east\": \"us-east-nj\"} }`
 *
 * `custom_relay_server` and `forced_servers` are optional additive fields.
 * Legacy payloads with only `region`/`apps` remain valid.
 */
int32_t swifttunnel_connect_ex(const char *options_json);

/**
 * Disconnect from the VPN.  Returns 0 on success.
 */
int32_t swifttunnel_disconnect(void);

/**
 * Get the current connection state as an integer code.
 *
 * | Code | State                    |
 * |------|--------------------------|
 * |  0   | Disconnected             |
 * |  1   | FetchingConfig           |
 * |  2   | Connecting               |
 * |  3   | ConfiguringSplitTunnel   |
 * |  4   | Connected                |
 * |  5   | Disconnecting            |
 * | -1   | Error                    |
 * | -2   | SDK not initialised      |
 */
int32_t swifttunnel_get_state(void);

/**
 * Get detailed connection state as JSON.  Returns null if SDK not initialised.
 * Caller must free the returned string.
 *
 * JSON shape:
 * ```json
 * {
 *   "state": "Connected",
 *   "code": 4,
 *   "region": "singapore",
 *   "endpoint": "1.2.3.4:51821",
 *   "assigned_ip": "V3-Relay",
 *   "relay_auth_mode": "authenticated",
 *   "split_tunnel_active": true,
 *   "tunneled_processes": ["RobloxPlayerBeta.exe"],
 *   "error": null
 * }
 * ```
 */
char *swifttunnel_get_state_json(void);

/**
 * Get currently tunnelled process names as a JSON array.
 * Returns null if not connected or SDK not initialised.
 * Caller must free the returned string.
 */
char *swifttunnel_get_tunneled_processes(void);

/**
 * Get relay packet statistics as JSON.
 * Returns null if not connected.
 * Caller must free the returned string.
 *
 * JSON shape: `{"packets_sent":123,"packets_recv":456}`
 */
char *swifttunnel_get_stats_json(void);

/**
 * Get auto-routing state as JSON.
 * Caller must free the returned string.
 */
char *swifttunnel_get_auto_routing_json(void);

/**
 * Trigger an immediate re-scan of tunnelled processes.
 * Returns 0 on success, negative on error.
 */
int32_t swifttunnel_refresh_processes(void);

/**
 * Register a callback for VPN state changes.
 *
 * Signature: `fn(state_code: i32, user_context: *mut c_void)`
 */
void swifttunnel_on_state_change(void (*cb)(int32_t, void*), void *ctx);

/**
 * Register a callback for errors.
 *
 * Signature: `fn(error_code: i32, message: *const c_char, user_context: *mut c_void)`
 */
void swifttunnel_on_error(void (*cb)(int32_t, const int8_t*, void*), void *ctx);

/**
 * Register a callback for process detection events.
 *
 * Signature: `fn(process_name: *const c_char, added: i32, user_context: *mut c_void)`
 */
void swifttunnel_on_process_detected(void (*cb)(const int8_t*, int32_t, void*), void *ctx);

/**
 * Register a callback for auto-routing events.
 *
 * Signature: `fn(event_json: *const c_char, user_context: *mut c_void)`
 */
void swifttunnel_on_auto_routing_event(void (*cb)(const int8_t*, void*), void *ctx);

/**
 * Get the last error message.  Returns null if no error.
 * Caller must free the returned string.
 */
char *swifttunnel_get_last_error(void);

/**
 * Get the last error code.  Returns 0 (`SUCCESS`) if no error.
 */
int32_t swifttunnel_get_last_error_code(void);

/**
 * Clear the stored error state.
 */
void swifttunnel_clear_error(void);

#endif  /* SWIFTTUNNEL_H */
